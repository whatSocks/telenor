= Title of GraphGist
:neo4j-version: 2.1.0
:author: Your Name Here
:description: A sentence description.
:twitter: @yourTwitter,
:tags: use-case:social network 


== Table of Contents

* *<<introduction, Introduction>>*
* *<<introduction2, Authorization and Access Control>>*
* *<<the_network, The Network>>*
** <<network_subtopic1, Network Subtopic 1>>
* *<<problem_1, Describing and Solving Problem 1>>*
** <<problem_1_subtopic1, Problem 1 Subtopic 1>>
* *<<problem_2, Describing and Solving Problem 2>>*
** <<problem_2_subtopic1, Problem 2 Subtopic 1>>
* *<<conclusion, Conclusion>>*
** <<conclusion_subtopic1, Conclusion Subtopic 1>>
** <<why_neo, Why Neo4j?>>
* *<<use_case, Use Case: Use Case Name>>*
* *<<appendix, Cypher Appendix>>*
** <<cypher_subtopic_1, Cypher Subtopic 1>>
* *<<references, References>>*

[[introduction]]
== Introduction to GraphGist

_Introduction content. Briefly introduce the graphgist and problems it solves._ 


[[introduction2]]
== Authorization and Access Control

Authorization and access control solutions store information about parties (e.g., ad‐ ministrators, organizational units, end-users) and resources (e.g., files, shares, network devices, products, services, agreements), together with the rules governing access to those resources; they then apply these rules to determine who can access or manipulate a resource. Access control has traditionally been implemented either using directory services or by building a custom solution inside an application’s backend. Hierarchical directory structures, however, cannot cope with the nonhierarchical organizational and resource dependency structures that characterize multiparty distributed supply chains. Hand-rolled solutions, particularly those developed on a relational database, suffer join pain as the dataset size grows, becoming slow and unresponsive, and ultimately deliv‐ ering a poor end-user experience.

A graph database can store complex, densely connected access control structures span‐ ning billions of parties and resources. Its structured yet schema-free data model sup‐ ports both hierarchical and nonhierarchical structures, while its extensible property model allows for capturing rich metadata regarding every element in the system. With a query engine that can traverse millions of relationships per second, access lookups over large, complex structures execute in milliseconds.

As with network management and analysis, a graph database access control solution allows for both top-down and bottom-up queries:

- Which resources—company structures, products, services, agreements, and end users—can a particular administrator manage? (Top-down)
- Which resource can an end user access?
- Given a particular resource, who can modify its access settings? (Bottom-up)

Graph database access control and authorization solutions are particularly applicable in the areas of content management, federated authorization services, social networking preferences, and software as a service (SaaS) offerings, where they realize minutes to milliseconds increases in performance over their hand-rolled, relational predecessors.


[[the_network]]
== The Network used in GraphGist

=== _Briefly describe the network._

_The network in this example is a social knowledge graph._  

=== _Describe your nodes and relationships._

This model comprises two hierarchies. In the first hierarchy, administrators within each customer organization are assigned to groups; these groups are then accorded various permissions against that organization’s organizational structure:

- ALLOWED_INHERIT connects an administrator group to an organizational unit, thereby allowing administrators within that group to manage the organizational unit. This permission is inherited by children of the parent organizational unit. We see an example of inherited permissions in the TeleGraph example data model in the relationships between Group 1 and Acme, and the child of Acme, Spinoff. Group 1 is connected to Acme using an ALLOWED_INHERIT relationship. Ben, as a member of Group 1, can manage employees both of Acme and Spinoff thanks to this AL LOWED_INHERIT relationship.
- ALLOWED_DO_NOT_INHERIT connects an administrator group to an organizational unit in a way that allows administrators within that group to manage the organi‐ zational unit, but not any of its children. Sarah, as a member of Group 2, can ad‐ minister Acme, but not its child Spinoff, because Group 2 is connected to Acme by an ALLOWED_DO_NOT_INHERIT relationship, not an ALLOWED_INHERIT relationship.
- DENIED forbids administrators from accessing an organizational unit. This permis‐ sion is inherited by children of the parent organizational unit. In the TeleGraph diagram, this is best illustrated by Liz and her permissions with respect to Big Co, Acquired Ltd, Subsidiary, and One-Map Shop. As a result of her membership of Group 4 and its ALLOWED_INHERIT permission on Big Co, Liz can manage Big Co. But despite this being an inheritable relationship, Liz cannot manage Acquired Ltd or Subsidiary; the reason being, Group 5, of which Liz is a member, is DE NIED access to Acquired Ltd and its children (which includes Subsidiary). Liz can, however, manage One-Map Shop, thanks to an ALLOWED_DO_NOT_INHERIT per‐ mission granted to Group 6, the last group to which Liz belongs.
-- DENIED takes precedence over ALLOWED_INHERIT, but is subordinate to AL LOWED_DO_NOT_INHERIT. Therefore, if an administrator is connected to a company by way of ALLOWED_DO_NOT_INHERIT and DENIED, ALLOWED_DO_NOT_INHERIT prevails.

=== Fine-Grained Relationships, or Relationships with Properties?

Notice that the TeleGraph access control data model uses fine-grained relationships (ALLOWED_INHERIT, ALLOWED_DO_NOT_INHERIT, and DENIED) rather than a single rela‐ tionship type qualified by properties—something like PERMISSION with allowed and inherited boolean properties. TeleGraph performance-tested both approaches and determined that the fine-grained, property-free approach was nearly twice as fast as the one using properties. For more details on designing relationships, see Chapter 4 of Graph Databases [ADD LINK TO BOOK].
==== _Sample Scenario_

_There are two types of nodes, users and topics. Users are connected to their buddies by the `IS_BUDDY` relationship, and are connected to topics by the `KNOWS_ABOUT` relationship. In this example, if Jacob is buddies with David, we're assuming that David also considers Jacob his buddy. Depending on what we want to model, we might have accepted a scenario where Jacob is buddies with David, but David is not buddies with Jacob._ 

_Each `KNOWS_ABOUT` relationship has the properties `correct` and `total`, reflecting how many times the user has been asked about a topic, and of these times, how many times the user has responded correctly.  Every edge is initialized with a default of `{correct:1, total:2 }`._


//hide
//setup
[source,cypher]
----
//create the nodes
//administrators
CREATE (`Ben`:administrator {name:'Ben'}),
	(`Sarah`:administrator {name:'Sarah'}),
	(`Liz`:administrator {name:'Liz'}),
	(`Phil`:administrator {name:'Phil'})

//groups
CREATE (`Group1`:group {name:'Group1'}),
	(`Group2`:group {name:'Group2'}),
	(`Group3`:group {name:'Group3'}),
	(`Group4`:group {name:'Group4'}),
	(`Group5`:group {name:'Group5'}),
	(`Group6`:group {name:'Group6'}),
	(`Group7`:group {name:'Group7'})

//companies
CREATE (`Acme`:company {name:'Acme'}),
	(`Spinoff`:company {name:'Spinoff'}),
	(`Startup`:company {name:'Startup'}),
	(`Skunkworkz`:company {name:'Skunkworkz'}),
	(`BigCo`:company {name:'BigCo'}),
	(`Aquired`:company {name:'Aquired'}),
	(`Subsidry`:company {name:'Subsidry'}),
	(`DevShop`:company {name:'DevShop'}),
	(`OneManShop`:company {name:'OneManShop'})

//employees
CREATE (`Arnold`:employee {name:'Arnold'}),
	(`Charlie`:employee {name:'Charlie'}),
	(`Emily`:employee {name:'Emily'}),
	(`Gordon`:employee {name:'Gordon'}),
	(`Lucy`:employee {name:'Lucy'}),
	(`Kate`:employee {name:'Kate'}),
	(`Alister`:employee {name:'Alister'}),
	(`Eve`:employee {name:'Eve'}),
	(`Gary`:employee {name:'Gary'}),
	(`Bill`:employee {name:'Bill'}),
	(`Mary`:employee {name:'Mary'})

//accounts
CREATE (`account1`:account {name:'Acct 1'}),
	(`account2`:account {name:'Acct 2'}),
	(`account3`:account {name:'Acct 3'}),
	(`account4`:account {name:'Acct 4'}),
	(`account5`:account {name:'Acct 5'}),
	(`account6`:account {name:'Acct 6'}),
	(`account7`:account {name:'Acct 7'}),
	(`account8`:account {name:'Acct 8'}),
	(`account9`:account {name:'Acct 9'}),
	(`account10`:account {name:'Acct 10'}),
	(`account11`:account {name:'Acct 11'}),
	(`account12`:account {name:'Acct 12'})

//create relationships

//administrator-group relationships
CREATE (`Ben`)-[:MEMBER_OF]->(`Group1`), (`Ben`)-[:MEMBER_OF]->(`Group3`), 
	(`Sarah`)-[:MEMBER_OF]->(`Group2`), (`Sarah`)-[:MEMBER_OF]->(`Group3`), 
	(`Liz`)-[:MEMBER_OF]->(`Group4`), (`Liz`)-[:MEMBER_OF]->(`Group5`), (`Liz`)-[:MEMBER_OF]->(`Group6`), 
	(`Phil`)-[:MEMBER_OF]->(`Group7`) 

//group-company relationships
CREATE (`Group1`)-[:ALLOWED_INHERIT]->(`Acme`),
	(`Group2`)-[:ALLOWED_DO_NOT_INHERIT]->(`Acme`),(`Group2`)-[:DENIED]->(`Skunkworkz`),
	(`Group3`)-[:ALLOWED_INHERIT]->(`Startup`),
	(`Group4`)-[:ALLOWED_INHERIT]->(`BigCo`),
	(`Group5`)-[:DENIED]->(`Aquired`),
	(`Group6`)-[:ALLOWED_DO_NOT_INHERIT]->(`OneManShop`),
	(`Group7`)-[:ALLOWED_INHERIT]->(`Subsidry`)

//company-company relationships
CREATE (`Spinoff`)-[:CHILD_OF]->(`Acme`),
	(`Skunkworkz`)-[:CHILD_OF]->(`Startup`),
	(`Aquired`)-[:CHILD_OF]->(`BigCo`),
	(`Subsidry`)-[:CHILD_OF]->(`Aquired`),
	(`DevShop`)-[:CHILD_OF]->(`Subsidry`)

//employee-company relationships
CREATE (`Arnold`)-[:WORKS_FOR]-(`Acme`),
	(`Charlie`)-[:WORKS_FOR]-(`Acme`),
	(`Emily`)-[:WORKS_FOR]-(`Spinoff`),
	(`Gordon`)-[:WORKS_FOR]-(`Startup`),
	(`Lucy`)-[:WORKS_FOR]-(`Startup`),
	(`Kate`)-[:WORKS_FOR]-(`Kate`),
	(`Alister`)-[:WORKS_FOR]-(`BigCo`),
	(`Eve`)-[:WORKS_FOR]-(`Aquired`),
	(`Gary`)-[:WORKS_FOR]-(`Subsidry`),
	(`Bill`)-[:WORKS_FOR]-(`OneManShop`),
	(`Mary`)-[:WORKS_FOR]-(`DevShop`)

//employee-account relationships
CREATE (`Arnold`)-[:HAS_ACCOUNT]-(`account1`),(`Arnold`)-[:HAS_ACCOUNT]-(`account2`),
	(`Charlie`)-[:HAS_ACCOUNT]-(`account3`),
	(`Emily`)-[:HAS_ACCOUNT]-(`account6`),
	(`Gordon`)-[:HAS_ACCOUNT]-(`account4`),
	(`Lucy`)-[:HAS_ACCOUNT]-(`account5`),
	(`Kate`)-[:HAS_ACCOUNT]-(`account7`),
	(`Alister`-[:HAS_ACCOUNT]-(`account8`),
	(`Eve`)-[:HAS_ACCOUNT]-(`account9`),
	(`Gary`)-[:HAS_ACCOUNT]-(`account11`),
	(`Bill`)-[:HAS_ACCOUNT]-(`account10`),
	(`Mary`)-[:HAS_ACCOUNT]-(`account12`)

RETURN *
LIMIT 50
----
//graph_result


[[network_subtopic1]]
=== Finding all accessible resources for an administrator

The TeleGraph application uses many different Cypher queries; we’ll look at just a few of them here.
First up is the ability to find all the resources an administrator can access. Whenever an onsite administrator logs in to the system, he is presented with a browser-based list of all the employees and employee accounts he can administer. This list is generated based on the results returned from the following query:

----
START admin=node:administrator(name={administratorName'}) MATCH paths=(admin)-[:MEMBER_OF]->()-[:ALLOWED_INHERIT]->()<-[:CHILD_OF*0..3]-(company)<-[:WORKS_FOR]-(employee)-[:HAS_ACCOUNT]->(account)
WHERE NOT ((admin)-[:MEMBER_OF]->()-[:DENIED]->()<-[:CHILD_OF*0..3]-(company)) RETURN employee.name AS employee, account.name AS account
UNION
START admin=node:administrator(name={administratorName'})
MATCH paths=(admin)-[:MEMBER_OF]->()-[:ALLOWED_DO_NOT_INHERIT]->()
----


_talk about result_

shows how this query matches all accessible resources for Sarah in the sample TeleGraph graph. Note that, because of the DENIED relationship from Group 2 to Skunk workz, Sarah cannot administer Kate and Account 7.


_note about Cypher_

Cypher supports both UNION and UNION ALL operators. UNION eliminates duplicate results from the final result set, whereas UNION ALL includes any duplicates.

[[problem_1_subtopic1]]
=== Problem 1 Subtopic 1

==== _Describe and solve the problem with prose and Cypher!_


[[problem_2]]
== Determining whether an administrator has access to a resource

The query we’ve just looked at returned a list of employees and accounts an administrator can manage. In a web application, each of these resources (employee, account) is accessible through its own URI. Given a friendly URI (e.g., http://TeleGraph/accounts/ 5436), what’s to stop someone from hacking a URI and gaining illegal access to an account?

What’s needed is a query that will determine whether an administrator has access to a specific resource. This is that query:

----
START admin=node:administrator(name={adminName'}), company=node:company(resourceName={resourceName'}) MATCH p=(admin)-[:MEMBER_OF]->()-[:ALLOWED_INHERIT]->()<-[:CHILD_OF*0..3]-(company)
WHERE NOT ((admin)-[:MEMBER_OF]->()-[:DENIED]->()<-[:CHILD_OF*0..3]-(company)) RETURN count(p) AS accessCount
UNION
START admin=node:administrator(name={adminName'}),
company=node:company(resourceName={resourceName'})
MATCH p=(admin)-[:MEMBER_OF]->()-[:ALLOWED_DO_NOT_INHERIT]->(company) RETURN count(p) AS accessCount
----

This query works by determining whether an administrator has access to the company to which an employee or an account belongs. How do we identify the company to which an employee or account belongs? Through clever use of indexes.
In the TeleGraph data model, companies are indexed both by their name, and by the names of their employees and employee accounts. Given a company name, employee name, or account name, we can, therefore, look up the relevant company node in the company index.


[[problem_3]]
== Finding administrators for an account

The previous two queries represent “top-down” views of the graph. The last TeleGraph query we’ll discuss here provides a “bottom-up” view of the data. Given a resource—an employee or account—who can manage it? Here’s the query:

----
START resource=node:resource(name={resourceName'})
MATCH p=(resource)-[:WORKS_FOR|HAS_ACCOUNT*1..2]-(company)-[:CHILD_OF*0..3]->()<-[:ALLOWED_INHERIT]-()<-[:MEMBER_OF]-(admin) WHERE NOT ((admin)-[:MEMBER_OF]->()-[:DENIED]->()<-[:CHILD_OF*0..3]-(company)) RETURN admin.name AS admin
UNION
START resource=node:resource(name={resourceName'})
MATCH p=(resource)-[:WORKS_FOR|HAS_ACCOUNT*1..2]-(company)<-[:ALLOWED_DO_NOT_INHERIT]-()<-[:MEMBER_OF]-(admin) RETURN admin.name AS admin
----








[[conclusion]]
== Conclusion


[[conclusion_subtopic1]]
=== Conclusion Subtopic 1

[[why_neo]]
=== Why Neo4j?

image:https://dl.dropboxusercontent.com/u/14493611/neo4j-logo.png[Neo4j Logo]

Modeling the resource graph in Neo4j was quite natural, since the domain being modeled is inherently a graph. Neo4j provided fast and secure access and answers to important questions like: Which subscriptions can a user access, does the user have access to the given resource, and which agreements is a customer party to? The speed and accuracy of these operations is quite critical, because users logging into the system are not able to proceed until the authorization calculation has completed.

By overcoming both the performance and the data currency limitations of the previous module, Neo4j enabled high performance and reliable execution of authorization rules during all access to protected data. The transition resulted not just in faster performance, but in more maintainable code, because the access rules could be expressed so much more easily in a graph. Query and response times were reduced to seconds, and even milliseconds in many cases, from many minutes.

*temporary storage of words here:*
_sub-second queries may be too much for GraphGist, if so, this section will have to be rewritten_

Neo4j offers the possibility of sub-second queries for densely connected permission trees, thereby improving the performance characteristics of the system. Moreover, Neo4j allows for faithfully reproducing a customer's structure and content hierarchies in the graph without modification, thereby eliminating the kinds of data duplication and denormalization that specialize a store for a particular application. By not having to specialize the data for a particular application's performance needs, Neo4j provides the basis for extending and reusing the customer graph in other applications.

[[use_case]]
== Use Case: Telenor

_logo of use case here_

Telenor Norway is the leading supplier of the country’s telecommunications and data services. With more than 3 million mobile subscribers, it is also the nation’s number one broadband provider, and part of Telenor Group: one of the world’s largest mobile operators.

Telenor’s systems expose customer and product data to a range of different channels, among others a self-service web solution where business customers may manage their own portfolio. System availability and access/retrieval response times are critical to customer satisfaction.

*temporary storage of words here:*

The existing COS Security system is around 10 years old. The system cannot scale to accommodate Telenor's channel growth and increasing customer numbers. Even today, client wait times are unacceptably long - in the order of many seconds. 

The case for replacing COS Security is based around the needs of two of Telenor's most significant customers. The first anticipates growing to be three times as big as it is today; the second requires a faster solution. In building a new COS middleware platform, Telenor expects to meet these immediate customers needs and provide for another ten years' growth.

Telenor have chosen Neo4j to represent the structure and content hierarchies, the relationships that associate master customers, their individual customers, agreements and subscriptions, and the permissions that determine an end-user's access to a customer's structure and content. Traversing the graph helps answer the following questions:

•	Which subscriptions can a user access?
•	Who is entitled to modify an agreement or subscription?
•	Which agreements is a customer party to?


[[appendix]]
== Cypher Appendix

Topics to cover

- MATCH vs START

[[cypher_subtopic_1]]
=== Cypher Subtopic 1

----
//CYPHER HERE. For example:
MATCH (a:sample)
RETURN a
----

_Explanation of non-trivial Cypher queries used._

[[references]]
== References

_some sample references:_

- Frederick, Michael T., Pallab Datta, and Arun K. Somani. "Sub-Graph Routing: A generalized fault-tolerant strategy for link failures in WDM Optical Networks." Computer Networks 50.2 (2006): 181-199.
- 'http://en.wikipedia.org/wiki/Samuel_Johnson[Networks, Crowds, and Markets]'
- 'http://jexp.de/blog/2014/03/sampling-a-neo4j-database/[Sampling a Neo4j Database]'
